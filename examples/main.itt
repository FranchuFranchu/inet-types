:(a b) ~ :(a b)
::(a) ~ ::(a)

#[ 
	Define the boolean type.
	These two lines say that:
	Bool.true: Bool
	Bool.false: Bool
]

::(:(Bool.true Bool)) ~ Bool.true
::(:(Bool.false Bool)) ~ Bool.false

#[
	Define an agent that consumes Bools.
	It is of type ~Bool.

	~Bool is the type that all agents that interact with Bool share.
	It is the supertype of the types of all agents that interact with Bool.

	By saying Bool.not: ~Bool, we're making a weak assertion about Bool.not
	We're saying that the only thing we know about it is that it can interact with Bool
]

::(:(Bool.not(value) type)) ~ Bool.not(::(ret_value ret_type)) {
	value = ret_value
	type = ~Bool
	#[ It returns a Boolean through its auxiliary port ]
	ret_type = Bool
}
Bool.not(x Bool) ~ Bool.true
Bool.not(x Bool) ~ Bool.false

#[ 
	Define the ~Erasure "trait" or "interface"
	Era consumes erasable things, so it's of type ~Erasure

]
::(:(Era ~Erasure)) ~ Era

#[
	Bool implements Erasure
]
~Erasure ~ Bool
Era ~ Bool.true
Era ~ Bool.false

::(:(Bool.and(x y) ~Bool)) ~ Bool.and(::(:(x ~Bool)) ::(:(y Bool)))
Bool.and(x x) ~ Bool.true
Bool.and(Era Bool.false) ~ Bool.false

#[
	Duplication trait
]
::(:(Dup(a b) ~Duplication)) ~ Dup(a b)

~Duplication ~ Bool
Dup(Bool.true Bool.true) ~ Bool.true
Dup(Bool.false Bool.false) ~ Bool.false

Dup(Bool Bool) ~ Bool

#[
	Lists
]


::(:(v t)) ~ List.nil {
	v = List.nil
	t = List(Bot)
}

::(:(v t)) ~ List.cons(x xs) {
	x = ::(:(xv t0))
	xs = ::(:(xsv ~List(t1)))
	t0 = Dup(~(t1) t2)
	v = List.cons(xv xsv)
	t = List(t2)
}

::(:(v t)) ~ List.push(::(:(elem elemt)) ::(:(out outt)) ) {
	v = List.push(elem out)
	t = ~List(t1)
	elemt = Dup(~(t1) t2)
	outt = List(t2)
}

List.cons(x xs) ~ List.push(elem out) {
	xs = List.push(elem tail)
	out = List.cons(x tail)
}
List.nil ~ List.push(elem out) {
	out = List.cons(elem List.nil)
}

#[
	Pair. Pair can also act as a function.
]

::(:(v t)) ~ Pair.new(:(av at) :(bv bt)) {
	t = Pair(at bt)
	v = Pair.new(av bv)
}

#[
	Define natural numbers
]

::(:(Nat.zero Nat)) ~ Nat.zero
::(:(Nat.succ(x) Nat)) ~ Nat.succ(::(:(x ~Nat)))

~Duplication ~ Nat
Dup(Nat.zero Nat.zero) ~ Nat.zero
Dup(Nat.succ(a0) Nat.succ(a1)) ~ Nat.succ(Dup(a0 a1))

Dup(Nat Nat) ~ Nat

~Nat ~ Bot
Dup(Bot Bot) ~ Bot
Bot ~ ~Duplication


::(:(List.range(x) ~Nat)) ~ List.range(::(:(x List(Nat))))
Nat.zero ~ List.range(List.cons(Nat.zero List.nil))
Nat.succ(Dup(a0 a1)) ~ List.range(out) {
	AddOne(List.cons(Nat.succ(x) xs)) ~ List.cons(x AddOne(xs))
	AddOne(List.nil) ~ List.nil
	::(:(AddOne(x) ~List(~Nat))) ~ AddOne(:(x List(Nat)))

	a0 = List.range(AddOne tail)
	out = List.cons(Nat.zero tail)
}

#[
	TODO: Doesn't work yet, because we can't conditionally implement traits.

	::(:(v t)) ~ List.map(::(:(av at)) ::(:(bv bt))) {
		v = List.map(av bv)
		t = ~List(input_type)
		at = Pair(input_type output_type)
		bt = List(output_type)
	}

	List.nil ~ List.map(Era List.nil)

	List.cons(x xs) ~ List.map(fun ret) {
		Dup(fun0 fun1) = fun
		Pair(in out) = fun0
		in = x
		xs = List.map(fun1 mapped_tail)
		ret = List.cons(out mapped_tail)
	}
]
Reduce[{
	List.range(?aa) = Nat.succ(Nat.succ(Nat.succ(zero)))
}]